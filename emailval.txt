
Al registro de usuario tu insertas un registro con un nuevo usuario pero en un campo de tipo 
booleano que sirve para distinguir si el proceso de registro finalizó o no(es decir si el usuario 
pincho en el link del email) debes activarlo en primera instancia a FALSE. Es decir rellenas todos 
los campos del usuario tras el registro(que no la confirmación) pero dejas en default '0' el campo
 de confirmacion_mail(por ejemplo)

Por otra parte cuando el usuario te envia los datos de registro tienes que crear una cadena 
codificada pero con la garantia de que no se pueda repetir para dos peticiones paralelas en 
el tiempo. Se suele hacer un md5 de uniqid de la ip del usuario:


Código PHP:
function getRealIP()
{
   
   if( $_SERVER['HTTP_X_FORWARDED_FOR'] != '' )
   {
      $client_ip =
         ( !empty($_SERVER['REMOTE_ADDR']) ) ?
            $_SERVER['REMOTE_ADDR']
            :
            ( ( !empty($_ENV['REMOTE_ADDR']) ) ?
               $_ENV['REMOTE_ADDR']
               :
               "unknown" );
   
      // los proxys van añadiendo al final de esta cabecera
      // las direcciones ip que van "ocultando". Para localizar la ip real
      // del usuario se comienza a mirar por el principio hasta encontrar
      // una dirección ip que no sea del rango privado. En caso de no
      // encontrarse ninguna se toma como valor el REMOTE_ADDR
   
      $entries = split('[, ]', $_SERVER['HTTP_X_FORWARDED_FOR']);
   
      reset($entries);
      while (list(, $entry) = each($entries))
      {
         $entry = trim($entry);
         if ( preg_match("/^([0-9]+.[0-9]+.[0-9]+.[0-9]+)/", $entry, $ip_list) )
         {
            // http://www.faqs.org/rfcs/rfc1918.html
            $private_ip = array(
                  '/^0./',
                  '/^127.0.0.1/',
                  '/^192.168..*/',
                  '/^172.((1[6-9])|(2[0-9])|(3[0-1]))..*/',
                  '/^10..*/');
   
            $found_ip = preg_replace($private_ip, $client_ip, $ip_list[1]);
   
            if ($client_ip != $found_ip)
            {
               $client_ip = $found_ip;
               break;
            }
         }
      }
   }
   else
   {
      $client_ip =
         ( !empty($_SERVER['REMOTE_ADDR']) ) ?
            $_SERVER['REMOTE_ADDR']
            :
            ( ( !empty($_ENV['REMOTE_ADDR']) ) ?
               $_ENV['REMOTE_ADDR']
               :
               "unknown" );
   }
   
   return $client_ip;
   
}
$user_ip=getRealIP();
$pass_fiable=md5(uniqid($user_ip)) 
Bien una vez que se supone que el script que recibe el registro obtiene esta clave única(es decir una cadena que sabemos sería casí imposible que se repitiera), lo que tenemos que hacer es insertar una relación de esa clave única con el identificador de usuario que activaría.

Es decir activamos todos los datos de usuario que procediesen, dejamos el campo booleano de confirmacion_mail a false de momento, insertamos un registro en nuestra tabla de confirmación que contiene nuestra clave única y el identificador de usuario que activaría.

Además enviamos un mail al usuario, con la dirección del script que realizaría la activación pero incluyendo en la dirección un paso de la clave única por query string.

Y luego en el script que recibe la confirmación, simplemente activamos el usuario cuya clave coincida con la pasada por query string(desde el mail del usuario). Eso sería con una consulta select y un update.

Y bueno de esta forma sabemos que la clave que mandamos no se puede repetir, y que al menos si el usuario confirma es porque se tomó la molestía de abrir el correo que indicó como suyo y pincha en el link de confirmación.

Obviamente se requiere una tabla suplementaria de confirmación de usuario con un campo para la clave única y otro para el id del usuario, y tambien se requiere un campo más para la tabla de usuarios que tengas, para meter el estado de la cuenta.